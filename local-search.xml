<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>GoLand注册服务器收集 --激活</title>
    <link href="/2019/03/02/GoLand%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%94%B6%E9%9B%86%20--%E6%BF%80%E6%B4%BB/"/>
    <url>/2019/03/02/GoLand%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%94%B6%E9%9B%86%20--%E6%BF%80%E6%B4%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="GoLand注册服务器收集-–激活"><a href="#GoLand注册服务器收集-–激活" class="headerlink" title="GoLand注册服务器收集 –激活"></a>GoLand注册服务器收集 –激活</h2><pre><code>http://idea.youbbs.org</code></pre><h2 id="插件推荐"><a href="#插件推荐" class="headerlink" title="插件推荐"></a>插件推荐</h2><ul><li>Afterglow Theme<br>这是一个主题插件，它基于sublime text的Afterglow主题，替代了侧边栏的文件图标和侧边栏的背景颜色，它是对Darcular主题的扩展。</li><li>Auto-Align<br>通过在项目中配置.ignore文件，可以在项目提交时，忽略目录下的部分文件，如数据库密码的配置文件等。Goland的.ignore插件适用.gitignore，hgignore，npmignore，.dockerignore，.chefignore，.cvsignore，。bzrignore等文件的编辑。<h2 id="两个不错的主题"><a href="#两个不错的主题" class="headerlink" title="两个不错的主题"></a>两个不错的主题</h2></li><li>Material Oceanic</li><li>darcula</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>goland</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin初学笔记(一)</title>
    <link href="/2019/03/02/kotlin/"/>
    <url>/2019/03/02/kotlin/</url>
    
    <content type="html"><![CDATA[<h1 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h1><div align=center> <img src="https://github.com/zhangzizhao404/markdown-pictures/blob/master/MyBlog/Kotlin/001/001.png?raw=true" srcset="/img/loading.gif" style="zoom:200%" /></div>    2018年9月的时候一个巧合短暂的接触到了kotlin语言,觉得很棒,我便学习了一段时间,但是后来还是全面投入golang开发了,今天整理文件的时候发现了这些笔记,想着还是分享到博客上来吧.东西不多初学者可以看看,也是我短暂的学习中的一点收获吧.<h4 id="Glide解析base64图片"><a href="#Glide解析base64图片" class="headerlink" title="Glide解析base64图片"></a>Glide解析base64图片</h4><pre><code class="kotlin"> //pictureBase64 = &quot;data:image/jpeg;base64,&quot; + base64 //base64为picture的base64编码 Glide.with(holder.imageView).load(pictureBase64).into(holder.imageView)</code></pre><h4 id="Glide解析图片Uri"><a href="#Glide解析图片Uri" class="headerlink" title="Glide解析图片Uri"></a>Glide解析图片Uri</h4><pre><code class="kotlin">Glide.with(imageView).load(pictureUri).into(imageView)</code></pre><h4 id="封装View"><a href="#封装View" class="headerlink" title="封装View"></a>封装View</h4><pre><code class="kotlin">class NavigationItem(var itemType: ItemType, var mText: String, var callback: (item: NavigationItem) -&gt; Unit)class NavigationBar:  AnkoComponent&lt;Context&gt; {    //TODO    fun addButton(navigationItem: NavigationItem) {        //TODO    }}</code></pre><h4 id="屏幕切换不保存数据问题"><a href="#屏幕切换不保存数据问题" class="headerlink" title="屏幕切换不保存数据问题"></a>屏幕切换不保存数据问题</h4><p>“Note: In order for the android system to restore the state of the views in your activity, each view must have a unique ID, supplied by the android:id attribute.“</p><p>即需给控件添加id</p>]]></content>
    
    
    
    <tags>
      
      <tag>Kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 18.04折腾之路</title>
    <link href="/2019/03/02/ubuntu%E6%8A%98%E8%85%BE%E4%B9%8B%E8%B7%AF/"/>
    <url>/2019/03/02/ubuntu%E6%8A%98%E8%85%BE%E4%B9%8B%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<p>#Ubuntu 18.04折腾之路</p><h3 id="更改系统时间（win10-Ubuntu双系统）"><a href="#更改系统时间（win10-Ubuntu双系统）" class="headerlink" title="更改系统时间（win10+Ubuntu双系统）"></a>更改系统时间（win10+Ubuntu双系统）</h3><p>以下两种方法均可</p><ul><li><p>Ubuntu终端输入</p><pre><code>timedatectl set-local-rtc 1 --adjust-system-clock</code></pre></li><li><p>win10  cmd输入</p><pre><code>Reg add HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation /v  RealTimeIsUniversal /t REG_DWORD /d 1    </code></pre><h3 id="Mac-主题桌面"><a href="#Mac-主题桌面" class="headerlink" title="Mac 主题桌面"></a>Mac 主题桌面</h3><p>效果:</p></li></ul><img src="https://github.com/zhangzizhao404/markdown-pictures/blob/master/MyBlog/Ubuntu18.04/111.png" srcset="/img/loading.gif" /><p>参考一个大神的视频:<a href="https://www.bilibili.com/video/av23152537" target="_blank" rel="noopener">https://www.bilibili.com/video/av23152537</a></p><h3 id="在恢复模式下修改文件"><a href="#在恢复模式下修改文件" class="headerlink" title="在恢复模式下修改文件"></a>在恢复模式下修改文件</h3><p>我在一天之内改文件改的Ubuntu不能解锁进入桌面,于是又探索了一下<br>首先进入恢复模式之后是不能修改文件的,要先输入以下命令</p><pre><code>mount -o remount,rw /</code></pre><p>这样就可以修改文件了,把你之前修改的文件改回原来的.按住Ctrl+Alt+delete就能重启了进入系统了.</p>]]></content>
    
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin初学笔记(二)--一个带编辑框弹窗的实现</title>
    <link href="/2019/03/02/%E4%B8%80%E4%B8%AA%E5%BC%B9%E7%AA%97/"/>
    <url>/2019/03/02/%E4%B8%80%E4%B8%AA%E5%BC%B9%E7%AA%97/</url>
    
    <content type="html"><![CDATA[<h3 id="弹窗封装"><a href="#弹窗封装" class="headerlink" title="弹窗封装"></a>弹窗封装</h3><p>如图所示</p><pre><code class="kotlin">class PopupsWindow : DialogFragment() {    //editText加id才能保证屏幕旋转时用户输入的文字不丢失    private val ID_EDITTEXT = 0    private var title: String? = null    private var message: String? = null    private var defaultText: String? = null    private lateinit var negativeButtonText: String    private lateinit var positiveButtonText: String    private lateinit var negativeButtonOnClickListener: View.OnClickListener    private lateinit var positiveButtonOnClickListener: View.OnClickListener    private lateinit var negativeButton: Button    private lateinit var positiveButton: Button    lateinit var editText: EditText    lateinit var errorTextView: TextView    private lateinit var messageText: TextView    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        val bundle = arguments        title = bundle!!.getString(&quot;title&quot;)        message = bundle.getString(&quot;message&quot;)        defaultText = bundle.getString(&quot;defaultText&quot;)    }    override fun onStart(){        super.onStart()        val dialog = dialog        if (dialog != null &amp;&amp; dialog.window != null){            val window = dialog.window            window!!.setLayout(dip(250), wrapContent)            window.setGravity(Gravity.CENTER)            window.setBackgroundDrawable(ColorDrawable(Color.TRANSPARENT))            //设置点击屏幕外弹窗不消失            this.isCancelable = false        }    }    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View?{        context?.let {            return with(it) {                verticalLayout {                    background = newGradientDrawable(-0x1, dip(1), -0x1, dip(10))                    background.alpha = 225                    textView(title) {                        textColor = -0x1000000                        textSize = 18f                        gravity = Gravity.START or Gravity.CENTER_VERTICAL                        singleLine = true                    }.lparams(width = wrapContent, height = wrapContent) {                        gravity = Gravity.CENTER_HORIZONTAL or Gravity.TOP                        topMargin = dip(10)                    }                    if (message != &quot;&quot;){                        messageText = textView(message) {                            textSize = 13f                            textColor = -0x8a8a8b                            gravity = Gravity.CENTER                        }.lparams(width = matchParent, height = wrapContent){                            topMargin = dip(10)                            marginEnd = dip(17)                            marginStart = dip(17)                        }                    }                    editText = editText {                        id = ID_EDITTEXT                        setText(defaultText)                        textColor = -0x1000000                        textSize = 16f                        gravity = Gravity.START or Gravity.CENTER_VERTICAL                        singleLine = true                        inputType = EditorInfo.TYPE_TEXT_VARIATION_URI                        imeOptions = EditorInfo.IME_ACTION_GO or EditorInfo.IME_FLAG_NO_EXTRACT_UI or EditorInfo.IME_FLAG_NO_FULLSCREEN or EditorInfo.IME_FLAG_NO_PERSONALIZED_LEARNING                        singleLine = true                        isFocusableInTouchMode = true                        setPaddingRelative(dip(5), dip(2), dip(5), dip(2))                        background = newGradientDrawable(-0x1, dip(1), -0x1, dip(0))                        addTextChangedListener(object :TextWatcher{                            override fun beforeTextChanged(p0: CharSequence?, p1: Int, p2: Int, p3: Int) { }                            override fun afterTextChanged(p0: Editable?) { }                            //editText文字改变时的操作                            override fun onTextChanged(p0: CharSequence?, p1: Int, p2: Int, p3: Int) {                                if (errorTextView.isShown){                                    background = newGradientDrawable(-0x1, dip(1), -0x1, dip(0))                                    errorTextView.text = null                                }                            }                        })                    }.lparams(width = matchParent, height = wrapContent) {                        gravity = Gravity.CENTER_HORIZONTAL                        topMargin = dip(10)                        marginEnd = dip(15)                        marginStart = dip(15)                    }                    errorTextView = textView {                        textColor = -0x10000                        textSize = 10f                        gravity = Gravity.END or Gravity.CENTER_VERTICAL                    }.lparams(width = wrapContent, height = dip(15)){                        marginEnd = dip(15)                        gravity = Gravity.END                    }                    view { backgroundColor = -0x1f1f20 }.lparams(width = matchParent, height = 1)                    linearLayout {                        negativeButton = button(negativeButtonText) {                            textSize = 16f                            textColor = -0xff8901                            background.alpha = 0                            setOnClickListener(negativeButtonOnClickListener)                        }.lparams(width = wrapContent, height = matchParent) {                            weight = 1f                        }                        view { backgroundColor = -0x1f1f20}.lparams(width = 1, height = matchParent)                        positiveButton = button(positiveButtonText) {                            textSize = 16f                            textColor = -0xff8901                            background.alpha = 0                            setOnClickListener(positiveButtonOnClickListener)                        }.lparams(width = wrapContent, height = matchParent) {                            weight = 1f                        }                    }.lparams(width = matchParent, height = dip(45)) {                        gravity = Gravity.BOTTOM                    }                }            }        }        return null    }    fun setCancelButton(buttonText: String, listener: View.OnClickListener){        this.negativeButtonText = buttonText        this.negativeButtonOnClickListener = listener    }    fun setConfirmButton(buttonText: String, listener: View.OnClickListener){        this.positiveButtonText = buttonText        this.positiveButtonOnClickListener = listener    }    //文本框内容不满足限制条件时，提示出错信息    fun setEditTextError(error : CharSequence){        editText.background = newGradientDrawable(-0x1, dip(1), -0x10000, dip(0))        errorTextView.text = error    }    fun isEditTextChange(): Boolean{        return editText.text.toString() != defaultText    }    private fun newGradientDrawable(        @ColorInt color: Int, stroke: Int, @ColorInt strokeColor: Int,        cornors: Int    ): GradientDrawable {        val drawable = GradientDrawable()        drawable.setColor(color)        drawable.setStroke(stroke, strokeColor)        drawable.cornerRadius = cornors.toFloat()        return drawable    }}</code></pre><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><pre><code class="kotlin">class CommonPopupsWindow(){    private lateinit var title:String    private lateinit var message: String    private lateinit var defaultText: String    private lateinit var editPopupsWindow: PopupsWindow    constructor(title: String, message: String, defaultText: String, activity:Activity) : this() {        this.title = title        this.message = message        this.defaultText = defaultText        this.activity = activity        editPopupsWindow = PopupsWindow()        val bundle = Bundle()        bundle.putString(&quot;title&quot;, title)        bundle.putString(&quot;message&quot;, message)        bundle.putString(&quot;defaultText&quot;, defaultText)        editPopupsWindow.arguments = bundle        activity.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_LOCKED    }    fun setButton(buttonText: String, listener: View.OnClickListener){        if (buttonText == &quot;取消&quot;){            editPopupsWindow.setCancelButton(buttonText, View.OnClickListener {                close()            })        }else{            editPopupsWindow.setConfirmButton(buttonText, listener)        }    }    fun getEditedText(): String{        return editPopupsWindow.editText.text.toString()    }    fun close(){        editPopupsWindow.dismiss()        activity.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED    }    fun show(fragmentManager: FragmentManager){        editPopupsWindow.let {            fragmentManager.beginTransaction().add(editPopupsWindow, &quot;iconUriEdit&quot;).commitAllowingStateLoss()        }    }    fun isEditTextChanged(): Boolean{        return editPopupsWindow.isEditTextChange()    }    fun setEditTextError(error: CharSequence){        editPopupsWindow.setEditTextError(error)    }}</code></pre><h4 id="注：其中的newGradientDrawable（）函数用来设置背景颜色、边框颜色、边框大小以及文本框圆角大小"><a href="#注：其中的newGradientDrawable（）函数用来设置背景颜色、边框颜色、边框大小以及文本框圆角大小" class="headerlink" title="注：其中的newGradientDrawable（）函数用来设置背景颜色、边框颜色、边框大小以及文本框圆角大小"></a>注：其中的newGradientDrawable（）函数用来设置背景颜色、边框颜色、边框大小以及文本框圆角大小</h4><pre><code class="kotlin">private fun newGradientDrawable(        @ColorInt color: Int, stroke: Int, @ColorInt strokeColor: Int,        cornors: Int    ): GradientDrawable {        val drawable = GradientDrawable()        drawable.setColor(color)        drawable.setStroke(stroke, strokeColor)        drawable.cornerRadius = cornors.toFloat()        return drawable    }</code></pre><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><pre><code class="kotlin">button(&quot;弹窗&quot;){    setOnClickListener{        val colorSetPopupWindow = CommonPopupsWindow(&quot;标题标题&quot;,&quot;message message                                                      message message message message                                                      &quot;, &quot;文本框默认内容&quot;)         colorSetPopupWindow.addButton(&quot;取消&quot;, View.OnClickListener { })         colorSetPopupWindow.addButton(&quot;确定&quot;, View.OnClickListener {                  //TODO 点击确定后所进行的操作        })         colorSetPopupWindow.show(supportFragmentManager)     }}.lparams(width = wrapContent, height = wrapContent){      topMargin = dip(100)      gravity  = Gravity.CENTER_HORIZONTAL}</code></pre><p>效果图:</p><div align=center> <img src="https://github.com/zhangzizhao404/markdown-pictures/blob/master/MyBlog/Kotlin/002/001.png?raw=true" srcset="/img/loading.gif" style="zoom:25%" alt = "弹窗" /><img src="https://github.com/zhangzizhao404/markdown-pictures/blob/master/MyBlog/Kotlin/002/002.png?raw=true" srcset="/img/loading.gif" style="zoom:25%" alt = "弹窗输入内容不符合规定" /></div>]]></content>
    
    
    
    <tags>
      
      <tag>Kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin初学笔记(三)--调用相机拍照&amp;&amp;调取图库</title>
    <link href="/2019/03/02/%E6%8B%8D%E7%85%A7&amp;&amp;%E8%AF%BB%E5%8F%96%E7%9B%B8%E5%86%8C/"/>
    <url>/2019/03/02/%E6%8B%8D%E7%85%A7&amp;&amp;%E8%AF%BB%E5%8F%96%E7%9B%B8%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<h4 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h4><pre><code class="kotlin">&lt;!-- 往SDCard写入数据权限 --&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;&lt;!-- 请求访问使用照相设备 --&gt;&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;</code></pre><h4 id="调取相机"><a href="#调取相机" class="headerlink" title="调取相机"></a>调取相机</h4><pre><code class="kotlin">private fun takePhoto() {        val intentToTakePhoto = Intent(MediaStore.ACTION_IMAGE_CAPTURE)        mPhotoPath = Environment.getExternalStorageDirectory().absolutePath + File.separator + &quot;photo.jpeg&quot;        photoUri = FileProvider.getUriForFile(                this,                BuildConfig.APPLICATION_ID + &quot;.provider&quot;,                File(mPhotoPath))        intentToTakePhoto.putExtra(MediaStore.EXTRA_OUTPUT, photoUri)        startActivityForResult(intentToTakePhoto, CAMERA_REQUEST_CODE)    }</code></pre><h4 id="调取相册"><a href="#调取相册" class="headerlink" title="调取相册"></a>调取相册</h4><pre><code class="kotlin">private fun choosePhoto() {        val intentToPickPic = Intent(Intent.ACTION_PICK, null)        intentToPickPic.setDataAndType(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, &quot;image/*&quot;)        startActivityForResult(intentToPickPic, GALLERY_REQUEST_CODE)    }</code></pre><h4 id="裁剪图片"><a href="#裁剪图片" class="headerlink" title="裁剪图片"></a>裁剪图片</h4><pre><code class="kotlin">private fun crapPicture(uri: Uri) {        var intent = Intent(&quot;com.android.camera.action.CROP&quot;)        intent.setDataAndType(uri, &quot;image/*&quot;)        intent.putExtra(&quot;aspectX&quot;, 1)        intent.putExtra(&quot;aspectY&quot;, 1)        intent.putExtra(&quot;outputX&quot;, 180)        intent.putExtra(&quot;outputY&quot;, 180)        intent.putExtra(&quot;scale&quot;, true)  //保持比例        //intent.putExtra(MediaStore.EXTRA_OUTPUT, tempUri) // 将裁剪后的图片关联到tempUri        intent.putExtra(&quot;return-data&quot;, true) //通过intent传输bitmap（过大时会OOM）        intent.putExtra(&quot;outputFormat&quot;, Bitmap.CompressFormat.JPEG.toString())        intent.putExtra(&quot;noFaceDetection&quot;, false)        intent = Intent.createChooser(intent, &quot;裁剪图片&quot;)        startActivityForResult(intent, REQUEST_PICKER_AND_CROP)    }</code></pre><h4 id="判断是否有权限，没有则申请（android-N以上）"><a href="#判断是否有权限，没有则申请（android-N以上）" class="headerlink" title="判断是否有权限，没有则申请（android N以上）"></a>判断是否有权限，没有则申请（android N以上）</h4><pre><code class="kotlin"> private val PERMISSION_STORAGE = arrayOf(&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;) private val PERMISSION_CAMERA = arrayOf(&quot;android.permission.CAMERA&quot;)if (ContextCompat.checkSelfPermission(this@BookmarkEditActivity, &quot;android.permission.CAMERA&quot; )!= PackageManager.PERMISSION_GRANTED) {                           ActivityCompat.requestPermissions(this@BookmarkEditActivity,                                                             PERMISSION_CAMERA,                                                             CAMERA_REQUEST_CODE)}else {    takePhoto()}if (ContextCompat.checkSelfPermission(this@BookmarkEditActivity, &quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; )!= PackageManager.PERMISSION_GRANTED) {                            ActivityCompat.requestPermissions(this@BookmarkEditActivity, PERMISSION_STORAGE, GALLERY_REQUEST_CODE)}else {    choosePhoto()}</code></pre><h4 id="界面回调方法"><a href="#界面回调方法" class="headerlink" title="界面回调方法"></a>界面回调方法</h4><pre><code class="kotlin">override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {        if (resultCode == Activity.RESULT_OK) {            when (requestCode) {                CAMERA_REQUEST_CODE -&gt; try {                    val bit = BitmapFactory.decodeStream(contentResolver.openInputStream(photoUri))                    // TODO 添加照片裁剪                    imageView.setImageBitmap(bit)                }catch (e: Exception) {                    e.printStackTrace()                }                REQUEST_PICKER_AND_CROP -&gt; try {                    if (data != null) {                    //从tempUri中读取图片                    //val bit = BitmapFactory.decodeStream(contentResolver.openInputStream(tempUri)))                    //从intent中取data （return—data设为true时）                        val bit: Bitmap = data.getParcelableExtra(&quot;data&quot;)                         val byteArrayPicture = ByteArrayOutputStream()                        bit.compress(Bitmap.CompressFormat.PNG, 100, byteArrayPicture)                        val encodingString = String(Base64.encode(byteArrayPicture.toByteArray(), Base64.DEFAULT))                        println(&quot;logA ${site.title} $encodingString&quot;)                        imageView.setImageBitmap(bit)                    }                }catch (e: Exception) {                    e.printStackTrace()                }                GALLERY_REQUEST_CODE -&gt; {                    if (data != null) {                        photoUri = data.data!!                    }                    crapPicture(photoUri)                }            }        }        super.onActivityResult(requestCode, resultCode, data)        }</code></pre><p>注：网上还有很多第三方库实现图片裁剪,可自行Google。</p><h4 id="权限申请回调"><a href="#权限申请回调" class="headerlink" title="权限申请回调"></a>权限申请回调</h4><pre><code class="kotlin">override fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray) {        when(requestCode) {            CAMERA_REQUEST_CODE -&gt; {                if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {                    takePhoto()                } else {                    Toast.makeText(this, &quot;Permission Denied&quot;, Toast.LENGTH_SHORT).show()                }            }            GALLERY_REQUEST_CODE -&gt; {                if (grantResults[0] == PackageManager.PERMISSION_GRANTED) {                    choosePhoto()                } else {                    Toast.makeText(this, &quot;Permission Denied&quot;, Toast.LENGTH_SHORT).show()                }            }        }        super.onRequestPermissionsResult(requestCode, permissions, grantResults)    }</code></pre><h4 id="注：android-N需要使用FileProvider来打开目录"><a href="#注：android-N需要使用FileProvider来打开目录" class="headerlink" title="注：android N需要使用FileProvider来打开目录"></a>注：android N需要使用FileProvider来打开目录</h4><p>问题参考：</p><p><a href="http://gelitenight.github.io/android/2017/01/29/solve-FileUriExposedException-caused-by-file-uri-with-FileProvider.html" target="_blank" rel="noopener">http://gelitenight.github.io/android/2017/01/29/solve-FileUriExposedException-caused-by-file-uri-with-FileProvider.html</a></p><p><a href="https://blog.csdn.net/hexingen/article/details/78508033" target="_blank" rel="noopener">https://blog.csdn.net/hexingen/article/details/78508033</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin初学笔记(四)--一个简单的framment实现</title>
    <link href="/2019/03/02/%E7%AE%80%E5%8D%95%E7%9A%84framment/"/>
    <url>/2019/03/02/%E7%AE%80%E5%8D%95%E7%9A%84framment/</url>
    
    <content type="html"><![CDATA[<h4 id="简单的framment"><a href="#简单的framment" class="headerlink" title="简单的framment"></a>简单的framment</h4><pre><code class="kotlin">interface IconEditFragmentDelegate {    fun choosePicture()}class IconEditFragment: DialogFragment(){    var delegate: IconEditFragmentDelegate? = null    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {        context?.let {            return with(it) {                verticalLayout {                    lparams(width = matchParent, height = wrapContent){                        gravity = Gravity.BOTTOM or Gravity.CENTER_HORIZONTAL                    }                    textView(&quot;从相册中选取图片&quot;) {                        textColor = CColor.BLACK                        textSize = 16f                        gravity = Gravity.CENTER                        setOnClickListener {                            delegate?.choosePicture()                        }                    }.lparams(width = matchParent, height = wrapContent) {                        gravity = Gravity.CENTER_HORIZONTAL                    }                    view { backgroundColor = CColor.Separator }.lparams(width = matchParent, height = 1)                    textView(&quot;xxxx&quot;) {                        textColor = CColor.BLACK                        gravity = Gravity.CENTER                        textSize = 16f                        setOnClickListener {                            //                        }                    }.lparams(width = matchParent, height = wrapContent) {                        gravity = Gravity.CENTER_HORIZONTAL                    }                    view { backgroundColor = CColor.Separator }.lparams(width = matchParent, height = 1)                    textView(&quot;xxxxx&quot;) {                        textColor = CColor.BLACK                        gravity = Gravity.CENTER                        textSize = 16f                        setOnClickListener {                            //                        }                    }.lparams(width = matchParent, height = wrapContent) {                        gravity = Gravity.CENTER_HORIZONTAL                    }                }            }        }        return null    }}</code></pre><h4 id="Activity中"><a href="#Activity中" class="headerlink" title="Activity中"></a>Activity中</h4><pre><code class="kotlin">private fun showIconEditFragment() {       var fragment = IconEditFragment()        fragment.let {            fragment.delegate = this            supportFragmentManager.beginTransaction().add(IDiconEditFragment,it).commitAllowingStateLoss()            iconEdit.visibility = View.VISIBLE        }    }override fun choosePicture() {        // TODO    }</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin初学笔记(五)--长按弹出气泡菜单</title>
    <link href="/2019/03/02/%E9%95%BF%E6%8C%89%E5%BC%B9%E5%87%BA%E6%B0%94%E6%B3%A1/"/>
    <url>/2019/03/02/%E9%95%BF%E6%8C%89%E5%BC%B9%E5%87%BA%E6%B0%94%E6%B3%A1/</url>
    
    <content type="html"><![CDATA[<h4 id="长按弹出气泡"><a href="#长按弹出气泡" class="headerlink" title="长按弹出气泡"></a>长按弹出气泡</h4><pre><code class="kotlin">interface PopupMenuListener {    fun onPopupMenuClick(position: Int)}class TipMenu (val context: Context) {    private val DEFAULT_NORMAL_TEXT_COLOR = Color.WHITE    private val DEFAULT_PRESSED_TEXT_COLOR = Color.WHITE    private val DEFAULT_TEXT_SIZE_DP = 14f    private val DEFAULT_TEXT_PADDING_LEFT_DP = 15.0f    private val DEFAULT_TEXT_PADDING_TOP_DP = 12.0f    private val DEFAULT_TEXT_PADDING_RIGHT_DP = 15.0f    private val DEFAULT_TEXT_PADDING_BOTTOM_DP = 12.0f    private val DEFAULT_NORMAL_BACKGROUND_COLOR = -0x34000000    private val DEFAULT_PRESSED_BACKGROUND_COLOR = -0x18888889    private val DEFAULT_BACKGROUND_RADIUS_DP = 8    private val DEFAULT_DIVIDER_COLOR = -0x65000001    private val DEFAULT_DIVIDER_WIDTH_DP = 0.5f    private val DEFAULT_DIVIDER_HEIGHT_DP = 20.0f    private lateinit var anchorView: View    private val indicatorView: View by lazy {        getDefaultIndicatorView(context)    }    private lateinit var menus: List&lt;String&gt;    private var popupMenuListener: PopupMenuListener? = null    private var popupWindow: PopupWindow? = null    private var textColorStateList: ColorStateList? = null    private var textSize: Float = dp2px(DEFAULT_TEXT_SIZE_DP).toFloat()    private var textPaddingLeft = dp2px(DEFAULT_TEXT_PADDING_LEFT_DP)    private var textPaddingTop: Int = dp2px(DEFAULT_TEXT_PADDING_TOP_DP)    private var textPaddingRight: Int = dp2px(DEFAULT_TEXT_PADDING_RIGHT_DP)    private var textPaddingBottom: Int = dp2px(DEFAULT_TEXT_PADDING_BOTTOM_DP)    private var normalBackgroundColor: Int = DEFAULT_NORMAL_BACKGROUND_COLOR        set(value) {            field = value            refreshBackgroundOrRadiusStateList()        }    private var pressedBackgroundColor: Int = DEFAULT_PRESSED_BACKGROUND_COLOR        set(value) {            field = value            refreshBackgroundOrRadiusStateList()        }    private var backgroundCornerRadius: Int = dp2px(DEFAULT_BACKGROUND_RADIUS_DP.toFloat())        set(value) {            field = value            refreshBackgroundOrRadiusStateList()        }    private var cornerBackground: GradientDrawable = GradientDrawable()    private var leftItemBackground: StateListDrawable = StateListDrawable()    private var rightItemBackground: StateListDrawable = StateListDrawable()    private var cornerItemBackground: StateListDrawable = StateListDrawable()    private var normalTextColor: Int = DEFAULT_NORMAL_TEXT_COLOR        set(value) {            field = value            refreshTextColorStateList(pressedTextColor, field)        }    private var pressedTextColor: Int = DEFAULT_PRESSED_TEXT_COLOR        set(value) {            field = value            refreshTextColorStateList(pressedTextColor, field)        }    private var dividerColor: Int = DEFAULT_DIVIDER_COLOR    private var dividerWidth: Int = dp2px(DEFAULT_DIVIDER_WIDTH_DP)    private var dividerHeight: Int = dp2px(DEFAULT_DIVIDER_HEIGHT_DP)    private var indicatorWidth: Int = 0    private var indicatorHeight: Int = 0    private var popupWindowWidth: Int = 0    private var popupWindowHeight: Int = 0    private val screenWidth: Int by lazy {        getDefaultScreenWidth()    }    private val screenHeight: Int by lazy {        getDefaultScreenHeight()    }    private var rawX: Float = 0f    private var rawY: Float = 0f    init {        refreshBackgroundOrRadiusStateList()        refreshTextColorStateList(pressedTextColor, normalTextColor)    }    fun bind(anchorView: View, menus: List&lt;String&gt;, popupMenuListener: PopupMenuListener?){        val position: IntArray = intArrayOf(0, 0)        this.anchorView = anchorView        this.menus = menus        this.popupMenuListener = popupMenuListener        this.popupWindow = null        this.anchorView.getLocationOnScreen(position)        rawX = (position[0] + this.anchorView.width / 2).toFloat()        rawY = (position[1] + this.anchorView.height / 2).toFloat()    }    fun showPopupListWindow(){        if (context is Activity &amp;&amp; context.isFinishing){            return        }        if (popupWindow == null) {            val contentView = LinearLayout(context)            contentView.layoutParams = LinearLayout.LayoutParams(wrapContent, wrapContent)            contentView.orientation = LinearLayout.VERTICAL            val layoutParams = if(indicatorView.layoutParams == null) {                LinearLayout.LayoutParams(wrapContent, wrapContent)            }else {                indicatorView.layoutParams as LinearLayout.LayoutParams            }            layoutParams.gravity = Gravity.CENTER            indicatorView.layoutParams = layoutParams            val viewParent = indicatorView.parent            if (viewParent is ViewGroup) {                viewParent.removeView(indicatorView)            }            val popupListContainer = LinearLayout(context)            popupListContainer.layoutParams = LinearLayout.LayoutParams(wrapContent, wrapContent)            popupListContainer.orientation = LinearLayout.HORIZONTAL            popupListContainer.setBackgroundDrawable(cornerBackground)            contentView.run {                addView(popupListContainer)                addView(indicatorView)            }            for (i in this.menus.indices) {                val textView = TextView(context)                textView.setTextColor(textColorStateList)                textView.setTextSize(TypedValue.COMPLEX_UNIT_PX, textSize)                textView.setPadding(textPaddingLeft, textPaddingTop, textPaddingRight, textPaddingBottom)                textView.isClickable = true                textView.setOnClickListener {                    popupMenuListener?.run {                        println(menus)                        onPopupMenuClick(i)                        hidePopupListWindow()                    }                }                textView.text =menus[i]                if (menus.size &gt; 1 &amp;&amp; i == 0) {                    textView.setBackgroundDrawable(leftItemBackground)                } else if (menus.size &gt; 1 &amp;&amp; i == menus.size - 1) {                    textView.setBackgroundDrawable(rightItemBackground)                } else if (menus.size == 1) {                    textView.setBackgroundDrawable(cornerItemBackground)                } else {                    textView.setBackgroundDrawable(getCenterItemBackground())                }                popupListContainer.addView(textView)                if (menus.size &gt; 1 &amp;&amp; i != menus.size - 1) {                    val divider = View(context)                    val lp = LinearLayout.LayoutParams(dividerWidth, dividerHeight)                    lp.gravity = Gravity.CENTER                    divider.layoutParams = lp                    divider.setBackgroundColor(dividerColor)                    popupListContainer.addView(divider)                }                if (indicatorWidth == 0) {                    indicatorWidth = if (indicatorView.layoutParams.width &gt; 0) indicatorView.layoutParams.width else getViewWidth(indicatorView)                }                if (indicatorHeight == 0) {                    indicatorHeight = if (indicatorView.layoutParams.height &gt; 0) indicatorView.layoutParams.height else getViewHeight(indicatorView)                }            }            if (popupWindowWidth == 0) popupWindowWidth =  getViewWidth(popupListContainer)            if (popupWindowHeight == 0) popupWindowHeight = getViewHeight(popupListContainer) + indicatorHeight            popupWindow = PopupWindow(contentView, popupWindowWidth, popupWindowHeight, true)            popupWindow?.run {                isTouchable = true                setBackgroundDrawable(BitmapDrawable())            }        }        val marginLeftScreenEdge = rawX        val marginRightScreenEdge = screenWidth - rawX        if (marginLeftScreenEdge &lt; popupWindowWidth / 2f) {            if (marginLeftScreenEdge &lt; indicatorWidth / 2f + backgroundCornerRadius) {                indicatorView.translationX = indicatorWidth / 2f + backgroundCornerRadius - popupWindowWidth / 2f            } else {                indicatorView.translationX = marginLeftScreenEdge - popupWindowWidth / 2f            }        } else if (marginRightScreenEdge &lt; popupWindowWidth / 2f) {            if (marginRightScreenEdge &lt; indicatorWidth / 2f + backgroundCornerRadius) {                indicatorView.translationX = popupWindowWidth / 2f - indicatorWidth / 2f - backgroundCornerRadius.toFloat()            } else {                indicatorView.translationX = popupWindowWidth / 2f - marginRightScreenEdge            }        } else {            indicatorView.translationX = 0f        }        showTipMenu()    }    private fun showTipMenu() {        popupWindow?.run {            if (!isShowing) showAtLocation(anchorView, Gravity.CENTER,                    rawX.toInt() - screenWidth / 2, rawY.toInt() - screenHeight / 2 - popupWindowHeight - indicatorHeight)        }    }    private fun refreshTextColorStateList(pressedTextColor: Int, normalTextColor: Int) {        val states = arrayOfNulls&lt;IntArray&gt;(2)        states[0] = intArrayOf(android.R.attr.state_pressed)        states[1] = intArrayOf()        val colors = intArrayOf(pressedTextColor, normalTextColor)        textColorStateList = ColorStateList(states, colors)    }    private fun getDefaultScreenWidth(): Int {        val wm = context.getSystemService(Context.WINDOW_SERVICE) as WindowManager        val outMetrics = DisplayMetrics()        wm.defaultDisplay.getMetrics(outMetrics)        return outMetrics.widthPixels    }    private fun getDefaultScreenHeight(): Int {        val wm = context.getSystemService(Context.WINDOW_SERVICE) as WindowManager        val outMetrics = DisplayMetrics()        wm.defaultDisplay.getMetrics(outMetrics)        return outMetrics.heightPixels    }    //!!不能获取matchParent的控件的宽度    private fun getViewWidth(view: View): Int {        view.measure(View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED), View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED))        return view.measuredWidth    }    //不能获取matchParent的控件的高度    private fun getViewHeight(view: View): Int {        view.measure(View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED), View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED))        return view.measuredHeight    }    private fun refreshBackgroundOrRadiusStateList() {        //left        val leftItemPressDrawable = GradientDrawable()        leftItemPressDrawable.setColor(pressedBackgroundColor)        leftItemPressDrawable.cornerRadii = floatArrayOf(backgroundCornerRadius.toFloat(),backgroundCornerRadius.toFloat(), 0f, 0f, 0f, 0f, backgroundCornerRadius.toFloat(), backgroundCornerRadius.toFloat())        val leftItemNormalDrawable = GradientDrawable()        leftItemNormalDrawable.setColor(Color.TRANSPARENT)        leftItemNormalDrawable.cornerRadii = floatArrayOf(backgroundCornerRadius.toFloat(), backgroundCornerRadius.toFloat(), 0f, 0f, 0f, 0f, backgroundCornerRadius.toFloat(), backgroundCornerRadius.toFloat())        leftItemBackground = StateListDrawable()        leftItemBackground.addState(intArrayOf(android.R.attr.state_pressed), leftItemPressDrawable)        leftItemBackground.addState(intArrayOf(), leftItemNormalDrawable)        // right        val rightItemPressedDrawable = GradientDrawable()        rightItemPressedDrawable.setColor(pressedBackgroundColor)        rightItemPressedDrawable.cornerRadii = floatArrayOf(0f, 0f, backgroundCornerRadius.toFloat(), backgroundCornerRadius.toFloat(), backgroundCornerRadius.toFloat(), backgroundCornerRadius.toFloat(), 0f, 0f)        val rightItemNormalDrawable = GradientDrawable()        rightItemNormalDrawable.setColor(Color.TRANSPARENT)        rightItemNormalDrawable.cornerRadii = floatArrayOf(0f, 0f, backgroundCornerRadius.toFloat(), backgroundCornerRadius.toFloat(), backgroundCornerRadius.toFloat(), backgroundCornerRadius.toFloat(), 0f, 0f)        rightItemBackground = StateListDrawable()        rightItemBackground.addState(intArrayOf(android.R.attr.state_pressed), rightItemPressedDrawable)        rightItemBackground.addState(intArrayOf(), rightItemNormalDrawable)        // corner        val cornerItemPressedDrawable = GradientDrawable()        cornerItemPressedDrawable.setColor(pressedBackgroundColor)        cornerItemPressedDrawable.cornerRadius = backgroundCornerRadius.toFloat()        val cornerItemNormalDrawable = GradientDrawable()        cornerItemNormalDrawable.setColor(Color.TRANSPARENT)        cornerItemNormalDrawable.cornerRadius = backgroundCornerRadius.toFloat()        cornerItemBackground = StateListDrawable()        cornerItemBackground.addState(intArrayOf(android.R.attr.state_pressed), cornerItemPressedDrawable)        cornerItemBackground.addState(intArrayOf(), cornerItemNormalDrawable)        cornerBackground = GradientDrawable()        cornerBackground.setColor(normalBackgroundColor)        cornerBackground.cornerRadius = backgroundCornerRadius.toFloat()    }    private fun getCenterItemBackground(): StateListDrawable {        val centerItemBackground = StateListDrawable()        val centerItemPressedDrawable = GradientDrawable()        centerItemPressedDrawable.setColor(pressedBackgroundColor)        val centerItemNormalDrawable = GradientDrawable()        centerItemNormalDrawable.setColor(Color.TRANSPARENT)        centerItemBackground.addState(intArrayOf(android.R.attr.state_pressed), centerItemPressedDrawable)        centerItemBackground.addState(intArrayOf(), centerItemNormalDrawable)        return centerItemBackground    }    fun hidePopupListWindow () {        if (context is Activity &amp;&amp; context.isFinishing) {            return        }        popupWindow?.run {            if (isShowing) {                dismiss()            }        }    }    private fun getDefaultIndicatorView(context: Context): View {        return getTriangleIndicatorView(context, dp2px(16f).toFloat(), dp2px(8f).toFloat(), DEFAULT_NORMAL_BACKGROUND_COLOR)    }    private fun getTriangleIndicatorView(context: Context, widthPixel: Float, heightPixel: Float, color: Int): View{        val indicator = ImageView(context)        val drawable = object : Drawable(){            override fun draw(canvas: Canvas) {                val path = Path()                val paint = Paint()                paint.color = color                paint.style = Paint.Style.FILL                path.run {                    moveTo(0f, 0f)                    lineTo(widthPixel, 0f)                    lineTo(widthPixel / 2, heightPixel)                }                path.close()                canvas.drawPath(path, paint)            }            override fun getOpacity(): Int {                return PixelFormat.TRANSLUCENT            }            override fun getIntrinsicWidth(): Int {                return widthPixel.toInt()            }            override fun getIntrinsicHeight(): Int {                return heightPixel.toInt()            }            override fun setColorFilter(colorFilter: ColorFilter?) { }            override fun setAlpha(alpha: Int) { }        }        indicator.setImageDrawable(drawable)        return indicator    }    private fun dp2px(value: Float): Int {        return TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,                value, context.resources.displayMetrics).toInt()    }}</code></pre><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><pre><code class="kotlin">button = button(&quot;tipMenu&quot;){                    setOnClickListener{                        val menus = java.util.ArrayList&lt;String&gt;()                        menus.add(&quot;按钮一&quot;)                        menus.add(&quot;按钮二&quot;)                        menus.add(&quot;按钮三&quot;)                        val tipMenu = TipMenu(context)                        tipMenu.bind(                            button,                            menus,                            popupMenuListener = object : PopupMenuListener {                                override fun onPopupMenuClick(position: Int) {                                    when(position){                                        0 -&gt;{                                            //TODO                                        }                                        1 -&gt;{                                            //TODO                                        }                                        2 -&gt;{                                            //TODO                                        }                                    }                                }                            })                        tipMenu.showPopupListWindow()                    }                }.lparams(width = wrapContent, height = wrapContent){                    topMargin = dip(100)                    gravity  = Gravity.CENTER_HORIZONTAL                }</code></pre><h4 id="效果图"><a href="#效果图" class="headerlink" title="效果图:"></a>效果图:</h4><div align=center> <img src="https://github.com/zhangzizhao404/markdown-pictures/blob/master/MyBlog/Kotlin/005/002.png?raw=true" srcset="/img/loading.gif" style="zoom:100%" alt= "气泡预览图"/></div>]]></content>
    
    
    
    <tags>
      
      <tag>Kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何科学上网</title>
    <link href="/2018/05/21/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    <url>/2018/05/21/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<p>   随着时间的推移网络长城越来越来完善，想要科学上网不再像是之前一样下载几个免费的软件就行的，笔者作为准程序员经常需要在网上查阅资料但是限于某度的结果实在是不如人意，最新的技术资料都在外面，所以科学上网自然必不可少。<br>  正好同学推荐碰到vultr有充值十美元赠25美元的活动，果断入手。想要购买其他的服务器也可以看大家自己喜好啦。接下来就是配置啦。配置时候在网上翻阅了几十个链接也没有系统的写搭建过程的，所以我就把我半天的折腾写啥来了。</p><h2 id="购买服务器"><a href="#购买服务器" class="headerlink" title="购买服务器"></a>购买服务器</h2><ul><li><p>这个看自己财力和喜好啦，自行购买。</p><h2 id="服务器端配置"><a href="#服务器端配置" class="headerlink" title="服务器端配置"></a>服务器端配置</h2></li><li><p>首先安装一个连接服务器端的软件  Putty</p><pre><code>sudo apt-get install putty</code></pre></li><li><p>添加一个快捷方式</p><pre><code>sudo ln -s  /usr/bin/putty  ./putty</code></pre></li><li><p>打开putty连接自己服务器（保证自己服务器开机）</p><div align=center> <img src="https://github.com/zhangzizhao404/markdown-pictures/blob/master/MyBlog/20180521/111.png?raw=true" srcset="/img/loading.gif"  /></div></li><li><p>输入账户和密码（自己购买后在自己服务信息页面可找到）</p><div align=center> <img src="https://github.com/zhangzizhao404/markdown-pictures/blob/master/MyBlog/20180521/222.png?raw=true" srcset="/img/loading.gif" /></div></li><li><p>安装shadowsockets</p><pre><code>apt install shadowsocks //pip install shaowsocks #或者使用其他仓库的版本</code></pre></li><li><p>配置文件</p></li></ul><p>新建并打开一个json文件</p><pre><code> vim /etc/shadowsocks/config.json     #可使用其他文本编辑起替换vim</code></pre><p>json文件内容如下</p><pre><code>{    &quot;server&quot;:&quot;my_server_ip&quot;,    &quot;local_address&quot;: &quot;127.0.0.1&quot;,    &quot;local_port&quot;:1080,        //本地端口    &quot;port_password&quot;:        //服务器端口和密码    {            &quot;port0&quot;:&quot;password0&quot;,               &quot;port1&quot;:&quot;password1&quot;    }    &quot;timeout&quot;:300,    &quot;method&quot;:&quot;aes-256-cfb&quot;,    &quot;fast_open&quot;: false}</code></pre><ul><li><p>配置完成后运行</p><pre><code>ssserver -c /etc/shadowsocks/config.json</code></pre><p>后台运行和停止</p><pre>ssserver -c /etc/shadowsocks.json -d startssserver -c /etc/shadowsocks.json -d stop</pre></li><li><p>设置开机自动启动（一般服务器不会自己重启，除非自己restart）</p><pre><code>vim /etc/rc.local</code></pre><p>再文件中添加如下命令</p><pre>#!/bin/bash -esudo ssserver -c /etc/shadowsocks.jsonexit 0</pre><p>给rc.local文件加权限</p><pre><code>#chmod +x /etc/rc.local</code></pre><p>服务器端就设置OK了！</p><h2 id="电脑端设置"><a href="#电脑端设置" class="headerlink" title="电脑端设置"></a>电脑端设置</h2></li><li><p>下载对应系统的ss客户端<br><a href="https://github.com/shadowsocks/shadowsocks-windows/releases" target="_blank" rel="noopener">windows 客户端</a><br><a href="https://github.com/shadowsocks/ShadowsocksX-NG/releases" target="_blank" rel="noopener">Mac客户端</a><br><a href="https://github.com/shadowsocks/shadowsocks-android/releases" target="_blank" rel="noopener">安卓客户端</a><br>Ubuntu</p><pre>sudo add-apt-repository ppa:hzwhuang/ss-qt5sudo apt-get updatesudo apt-get install shadowsocks-qt5</pre><p>注：使用Ubnutu18.04安装Shadowsocks-Qt5时会出现“E: 仓库 “<a href="http://ppa.launchpad.net/hzwhuang/ss-qt5/ubuntu" target="_blank" rel="noopener">http://ppa.launchpad.net/hzwhuang/ss-qt5/ubuntu</a> bionic Release” 没有 Release 文件“的错误<br>这是需要编辑/etc/apt/sources.list.d/hzwhuang-ubuntu-ss-qt5-bionic.list 文件，将bionic (18.04版本代号)改成xenial（16.04版本代号）。然后再执行 ：</p><pre>sudo apt-get updatesudo apt-get install shadowsocks-qt5</pre>就可以打开客户端图形化界面配置了 <div align=center> <img src="https://github.com/zhangzizhao404/markdown-pictures/blob/master/MyBlog/20180521/333.png?raw=true" srcset="/img/loading.gif"  /></div>## 配置浏览器</li><li><p>Firefox浏览器<br>设置→首选项→高级→网络→链接→设置→手动配置代理→<br>  socks主机：127.0.0.1<br>  端口：1080（自己设定和服务器段本地端口相同）<br>  选择SOCKS_v5<br>→确定</p></li><li><p>chrome浏览器<br>设置→更多工具→扩展工具→打开 开发者模式→<br>将SwitchyOmega.crx拖进浏览器   添加成功后在SwitchyOmega页面<br>选择导入导出→从备份文件恢复→选择OmegaOptions.bak文件<br>就可以了！<br><a href="https://pan.baidu.com/s/1Byy91a2JNHjimUWkSXQNfw" target="_blank" rel="noopener">文件下载地址</a> 密码：8ijr</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>翻墙</tag>
      
      <tag>科学上网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 语言异常处理</title>
    <link href="/2017/09/04/Go%20%E8%AF%AD%E8%A8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/2017/09/04/Go%20%E8%AF%AD%E8%A8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>“ Go语言追求简洁优雅，所以，Go语言不支持传统的 try…catch…finally 这种异常，因为Go语言的设计者们认为，将异常与控制结构混在一起会很容易使得代码变得混乱。因为开发者很容易滥用异常，甚至一个小小的错误都抛出一个异常。在Go语言中，使用多值返回来返回错误。不要用异常代替错误，更不要用来控制流程。在极个别的情况下，也就是说，遇到真正的异常的情况下（比如除数为0了）。才使用Go中引入的Exception处理：defer, panic, recover。”</p><p>这几个异常的使用场景可以这么简单描述：Go中可以抛出一个panic的异常，然后在defer中通过recover捕获这个异常，然后正常处理。<br>例：</p><pre><code>package mainimport &quot;fmt&quot;func main(){    defer func(){        // 必须要先声明defer，否则不能捕获到panic异常        fmt.Println(&quot;c&quot;)        if err:=recover();err!=nil{            fmt.Println(err)     // 这里的err其实就是panic传入的内容，55        }        fmt.Println(&quot;d&quot;)    }()    f()}func f(){    fmt.Println(&quot;a&quot;)    panic(55)    fmt.Println(&quot;b&quot;)    fmt.Println(&quot;f&quot;)}</code></pre><p>结果：</p><pre><code>    a    c    55    d    exit code 0, process exited normally.</code></pre><p>参考： <a href="http://blog.csdn.net/ghost911_slb/article/details/7831574" target="_blank" rel="noopener">http://blog.csdn.net/ghost911_slb/article/details/7831574</a></p><h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>defer的思想类似于C++中的析构函数，不过Go语言中“析构”的不是对象，而是函数，defer就是用来添加函数结束时执行的语句。注意这里强调的是添加，而不是指定，因为不同于C++中的析构函数是静态的，Go中的defer是动态的。</p><pre><code>func f() (result int) {    defer func() {        result++    }()    return 0}</code></pre><p>上面函数返回1，因为defer中添加了一个函数，在函数返回前改变了命名返回值的值。是不是很好用呢。但是，要注意的是，如果我们的defer语句没有执行，那么defer的函数就不会添加，如果把上面的程序改成这样：</p><pre><code>func f() (result int) {      return 0      defer func() {            result++      }()      return 0}</code></pre><p>上面的函数就返回0了，因为还没来得及添加defer的东西，函数就返回了。</p><p>另外值得一提的是，defer可以多次，这样形成一个defer栈，后defer的语句在函数返回时将先被调用。</p><h2 id="painc"><a href="#painc" class="headerlink" title="painc"></a>painc</h2><p>panic 是用来表示非常严重的不可恢复的错误的。在Go语言中这是一个内置函数，接收一个interface{}类型的值（也就是任何值了）作为参数。panic的作用就像我们平常接触的异常。不过Go可没有try…catch，所以，panic一般会导致程序挂掉（除非recover）。所以，Go语言中的异常，那真的是异常了。你可以试试，调用panic看看，程序立马挂掉，然后Go运行时会打印出调用栈。<br>但是，关键的一点是，即使函数执行的时候panic了，函数不往下走了，运行时并不是立刻向上传递panic，而是到defer那，等defer的东西都跑完了，panic再向上传递。所以这时候 defer 有点类似 try-catch-finally 中的 finally。<br>panic就是这么简单。抛出个真正意义上的异常。</p><h2 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h2><p>上面说到，panic的函数并不会立刻返回，而是先defer，再返回。这时候（defer的时候），如果有办法将panic捕获到，并阻止panic传递，那就异常的处理机制就完善了。</p><p>Go语言提供了recover内置函数，前面提到，一旦panic，逻辑就会走到defer那，那我们就在defer那等着，调用recover函数将会捕获到当前的panic（如果有的话），被捕获到的panic就不会向上传递了，于是，世界恢复了和平。你可以干你想干的事情了。</p><p>不过要注意的是，recover之后，逻辑并不会恢复到panic那个点去，函数还是会在defer之后返回。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Painc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用hexo搭建自己的博客</title>
    <link href="/2017/08/27/hexo%20+github%20%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <url>/2017/08/27/hexo%20+github%20%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<div align=center> <img src="https://github.com/zhangzizhao404/markdown-pictures/blob/master/MyBlog/Hexo.png?raw=true" srcset="/img/loading.gif" style="zoom:50%" /></div>## 准备工作- 下载node.js并安装（官网下载安装），默认会安装npm。- 下载安装git（官网下载安装） - 下载安装hexo。方法：打开cmd 运行npm install -g hexo（要翻墙）<h2 id="本地搭建hexo博客"><a href="#本地搭建hexo博客" class="headerlink" title="本地搭建hexo博客"></a>本地搭建hexo博客</h2><ul><li>新建一个文件夹，如MyBlog</li><li>进入该文件夹内，右击运行git，输入：hexo init（生成hexo模板，可能要翻墙）</li><li>生成完模板，运行npm install（目前貌似不用运行这一步）</li><li>最后运行：hexo server （运行程序，访问本地localhost:4000可以看到博客已经搭建成功）</li></ul><h2 id="将博客与自己Github关联"><a href="#将博客与自己Github关联" class="headerlink" title="将博客与自己Github关联"></a>将博客与自己Github关联</h2><ul><li>在Github上创建名字为XXX.github.io的项目，XXX为自己的github用户名。</li><li>打开本地的MyBlog文件夹项目内的_config.yml配置文件，将其中的type设置为git<pre><code>    deploy    type: git    repository: git@github.com:zhangzizhao404/zhangzizhao404.github.io.git    branch: master</code></pre>（Linux系统repository 使用ssh）</li><li>运行：npm install hexo-deployer-git –save</li><li>运行：hexo g（本地生成静态文件）</li><li>运行：hexo d（将本地静态文件推送至Github）</li><li>进入Github 中XXX.github.io项目 setting 中找到gitpage访问<a href="https://zhangzizhao404.github.io/" target="_blank" rel="noopener">https://zhangzizhao404.github.io/</a></li></ul><h2 id="添加新文章"><a href="#添加新文章" class="headerlink" title="添加新文章"></a>添加新文章</h2><p>打开Hexo目录下的source文件夹，所有的文章都会以md形式保存在_post文件夹中，只要在_post文件夹中新建md类型的文档，就能在执行hexo g的时候被渲染。 新建的文章头需要添加一些yml信息，如下所示：</p><hr><pre><code>title: hello-world   //在此处添加你的标题。date: 2014-11-7 08:55:29   //在此处输入你编辑这篇文章的时间。categories: Exercise   //在此处输入这篇文章的分类。toc: true  //在此处设定是否开启目录，需要主题支持。</code></pre><hr><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>如果成功完成了上述的全部步骤，恭喜你，你已经搭建了一个最为简单且基础的博客。但是这个博客还非常简单， 没有个人的定制，操作也比较复杂，下面的进阶技巧将会让你获得对Hexo更为深入的了解。</p><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><p>博客已经搭建好，也能通过github的域名访问，但总归还是用自己的域名比较舒服。因为我们需要设置将自己的域名绑定到github这个博客项目上。</p><ul><li><p>域名提供商设置<br>  添加2条A记录：<br>  @—&gt;192.30.252.154<br>  @—&gt;192.30.252.153</p><p>  添加一条CNAME记录：<br>  CNAME—&gt;tengzhangchao.github.io</p></li><li><p>博客添加CNAME文件<br>配置完域名解析后，进入博客目录，在source目录下新建CNAME文件，写入域名，如：kongqi404.top</p></li><li><p>运行：hexo g</p></li><li><p>运行：hexo d</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
