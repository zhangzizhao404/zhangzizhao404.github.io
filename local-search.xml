<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux常用命令</title>
    <link href="/2019/04/02/linux%E8%BE%BE%E4%BA%BA%E5%85%BB%E6%88%90/"/>
    <url>/2019/04/02/linux%E8%BE%BE%E4%BA%BA%E5%85%BB%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h4 id="软硬链接："><a href="#软硬链接：" class="headerlink" title="软硬链接："></a>软硬链接：</h4><p>硬链接：i节点相同， 实际是同一个文件，删除其中一个不影响两外一个，不能跨分区，不能针对目录使用</p><pre><code class="shell">ln xxx aaa    </code></pre><p>软连接：删除链接不影响源文件，删除原文件不能通过链接访问文件，类似于win快捷方式，</p><p><strong>做软连接 源文件地址必须是绝对路径，不写绝对路径默认是别的的是软连接所在目录</strong></p><pre><code class="shell">ln -s xxx aaa</code></pre><h4 id="搜索命令"><a href="#搜索命令" class="headerlink" title="搜索命令"></a>搜索命令</h4><p><strong>locate</strong></p><pre><code class="shell">locate //只能搜索文件名find //资源耗费比较多</code></pre><p>locate 搜索</p><p>数据库(位置（ubuntu）：/var/lib/mlocate不同的系统名字数据库不一样)</p><pre><code class="shell">sudo updatedb //更新数据库</code></pre><p>搜索规则配置文件：</p><pre><code class="shell">/etc/updatedb.conf</code></pre><p><strong>whereis</strong></p><p>搜索系统命令位置、及其帮助文档</p><pre><code class="shell">-b 命令位置-m 帮助文档的位置</code></pre><p><strong>which</strong></p><p>搜索系统命令位置、及其别名</p><p><strong>find</strong></p><p>搜索文件  【范围】 【搜索条件】</p><p>使用通配符进行模糊搜索</p><pre><code class="shell">*  匹配所有内容? 匹配人一个字符[] 匹配扩号内任意一个字符-iname 不区分大小写-user xx 按所有者搜索-nouser 查找没有所有者的文件（内核文件，外来文件否则就是垃圾文件）-mtime +10 +10 查找十天前修改的文件 -10 十天内... 10 十天当天...-actime 文件访问时间  -ctime 改变文件属性 -mtime 修改文件内容-size 25k  查找大小是25k的文件， 单位：k小写 M大写，不写默认为数据块-inum 262422 查找i节点是xxx的文件-a 逻辑与-o 逻辑或-exec ...进行对应操作 {} \；</code></pre><p><strong>grep</strong></p><p>使用正则表达式匹配</p><h4 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h4><p><strong>man</strong></p><p>man xxx(命令) 获取命令的帮助选项</p><pre><code class="shell">man -f  xxx命令 可以查看等级      相当于wharis man -k xxx  帮助文档中含有xxx 关键字的命令的帮助文档</code></pre><p>xxx –<strong>help</strong></p><p>含中文</p><p><strong>help</strong></p><p>shell 内部命令</p><p><strong>info</strong></p><p>一个巨大的帮助文档，不常用</p><pre><code class="shell">-u  -n -p -q</code></pre><p>压缩解压缩命令</p><p>.zip .gz .bz2 .tar.gz .tar.bz2</p><p><strong>zip    upzip</strong> </p><p>压缩完不一定比压缩前小</p><pre><code class="shell">zip xxx zzz 可不带扩展名，但最好带上方便阅读zzz-&gt;xxxzip -r xxx  zzz 压缩文件夹</code></pre><p><strong>gzip</strong></p><pre><code class="shell">gzip xxx 源文件会消失gzip -c xxx &gt; zzz 不消失gzip -r xxx 压缩文件夹中的子目录gzip -dgunzip xxx 解压缩gunzip -r 目录</code></pre><p><strong>bzip2</strong></p><p>不能压缩目录</p><pre><code class="shell">bzip -k 保留原文件</code></pre><p><strong>tar</strong></p><p>打包命令</p><pre><code class="shell">-c: 打包-v：显示过程-f: 指定打包后的文件名-x: 解打包命令-z: 压缩为.tar.gz-j: 压缩为.tar.bz2-c：压缩-x: 解压缩-t: 测试  只查看不解压</code></pre><h4 id="关机重启命令"><a href="#关机重启命令" class="headerlink" title="关机重启命令"></a>关机重启命令</h4><p><strong>shutdown</strong></p><p>命令比较安全</p><pre><code class="shell">-c-h-r</code></pre><p>其他关机命令</p><pre><code class="shell">//不安全halt poweroffinit 0init 6 重启</code></pre><p><strong>runlevel</strong></p><p>查看当前系统运行级别</p><pre><code class="shell">cat /etc/inittab 级别说明</code></pre><p><strong>logout</strong></p><p>正确断开连接</p><h4 id="挂载命令"><a href="#挂载命令" class="headerlink" title="挂载命令"></a>挂载命令</h4><p><strong>mount</strong></p><p>查看当前挂载的分区</p><pre><code class="shell">/etc/fstab 开机自动自动挂载程序命令文件-a 依据上面文件自动挂载-t 文件系统 iso9600（光盘）ext3 ext4-o 特殊操作 可google</code></pre><p>挂载光盘：</p><pre><code class="shell">mkdir /mnt/cdrom#-t 可省略mount -t iso9660 /dev/sro /mnt/cdrom </code></pre><p>卸载：</p><pre><code class="shell">umount 设备文件名 or 挂载点</code></pre><p>挂载优盘：</p><pre><code class="shell">fdisk -l 查看当前的设备# vfat指的是fat32 # Linux不支持NTFS  Linux 可装ntfs -3g  读ntfs分区不可写 # sdb1是设备名字  不确定需根据第一条命令判断mount -t vfat /dev/sdb1 /mnt/usb/</code></pre><h4 id="用户登录查看"><a href="#用户登录查看" class="headerlink" title="用户登录查看"></a>用户登录查看</h4><p><strong>w</strong></p><pre><code class="shell">w16:19:26 up  6:23,  1 user,  load average: 3.39, 3.74, 3.98USER     TTY      来自           LOGIN@   IDLE   JCPU   PCPU WHATkongqi   :0       :0               10:01   ?xdm?   2:25m  0.00s /usr/lib/gdm3/gdm-x-session --run-script env GNOME_SHELL_SESSION_MODE=ubuntu gnome-session --session=ubuntu</code></pre><p><strong>who</strong></p><pre><code class="shell">whokongqi   :0           2019-03-28 10:01 (:0)</code></pre><p><strong>last</strong> </p><p>查看的是/var/log/wtmp文件</p><p>历史登录用户信息、系统重启时间</p><p><strong>lastlog</strong></p><p>查看的是/var/log/lastlog文件</p><p>所有用户的历史登录信息</p><p><strong>其他</strong></p><p><strong>echo</strong></p><pre><code class="shell">#支持反斜杠调整的输出格式\t \n \b...  十六进制  颜色输出  echo -e </code></pre><h4 id="shell概述"><a href="#shell概述" class="headerlink" title="shell概述"></a>shell概述</h4><p><strong>alias</strong></p><p>别名优先级高于系统命令</p><pre><code class="shell">#临时设定alias 别名= 原名unalias#永久生效修改~/.bashrc文件</code></pre><p><strong>history</strong></p><p>默认保存一千条，/etc/profile可修改条数</p><pre><code class="shell">-c: 清空历史命令-w: 将内存中的历史命令写入文件中~/.bash_history!n!!!字符串 调用最后一个以字符串开头的命令</code></pre><p><strong>输出重定向</strong></p><pre><code class="shell">#标准输出 有空格命令 &gt; 文件  以覆盖的方式命令 &gt;&gt; 文件 以添加的方式#报错信息 无空格2&gt;文件    2&gt;&gt; #不用区分错误还是正确命令 &gt; 文件 2&gt;&amp;1命令 &gt;&gt; 文件 2&gt;&amp;1#不用区分错误还是正确命令 &amp;&gt; 文件 2&gt;&amp;1命令 &amp;&gt;&gt; 文件 2&gt;&amp;1#错误日志进文件2 正确日志文件1命令 &gt;&gt; 文件1 2&gt;&gt;文件2#/dev/null 相当于垃圾站 输出的东西被丢弃命令 &amp;&gt;/dev/null</code></pre><p><strong>输入重定向</strong></p><p><strong>wc</strong></p><pre><code class="shell">-c:  字节数-w： 单词数-l： 行数&lt; 输入 &lt;可省略</code></pre><p><strong>多命令顺序执行</strong></p><pre><code class="shell">A ; B ; C 链接  多命令顺序执行 B 出现错误后不影响C执行A &amp;&amp; B A正确执行后才执行BA || B A不正确执行就执行Beg：ls &amp;&amp; echo yes || echo no</code></pre><p><strong>文件格式化一些例子</strong></p><pre><code class="shell">#将文件a和b中相同的行去重， -r降序排列   -k1 第一列排序 -u 相同的只保留一份cat a.txt b.txt | sort -r -k1,1 -u &gt;&gt; xxx.txt </code></pre><p><strong>利用jq 格式化json字符串</strong></p><pre><code class="shell">#将./aaa.txt 中的json id和nick字段并放到xxx.txt# {xxx;xxx;xxx} &gt;&gt; xxx   {}内为组操作{printf &quot;%10s &quot; &quot;ID&quot;; printf &quot;%20s\n&quot; &quot;NICK&quot; }&gt;&gt; xxx.txt; while read line; doID=$(echo &quot;$line&quot; | jq &quot;.data.id&quot;);NICK=$(echo &quot;$line&quot; | jq -r &quot;.data.nick&quot;);{printf &quot;%10s &quot; &quot;$ID&quot;; printf &quot;%20s\n&quot; &quot;$NICK&quot;} &gt;&gt; xxx.txt;done &lt; ./aaa.txt</code></pre><p><strong>curl 请求</strong></p><pre><code class="shell">curl -X POST -d &#39;{&quot;mid&quot;:19758655}&#39; https://wkop-api.xiaoniangao.cn/student/info &gt;&gt; output.txt</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 18.04折腾之路</title>
    <link href="/2019/03/02/ubuntu%E6%8A%98%E8%85%BE%E4%B9%8B%E8%B7%AF/"/>
    <url>/2019/03/02/ubuntu%E6%8A%98%E8%85%BE%E4%B9%8B%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="更改系统时间（win10-Ubuntu双系统）"><a href="#更改系统时间（win10-Ubuntu双系统）" class="headerlink" title="更改系统时间（win10+Ubuntu双系统）"></a>更改系统时间（win10+Ubuntu双系统）</h3><p>以下两种方法均可</p><ul><li><p>Ubuntu终端输入</p><pre><code>timedatectl set-local-rtc 1 --adjust-system-clock</code></pre></li><li><p>win10  cmd输入</p><pre><code>Reg add HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation /v  RealTimeIsUniversal /t REG_DWORD /d 1    </code></pre><h3 id="Mac-主题桌面"><a href="#Mac-主题桌面" class="headerlink" title="Mac 主题桌面"></a>Mac 主题桌面</h3><p>效果:</p></li></ul><img src="https://github.com/zhangzizhao404/markdown-pictures/blob/master/MyBlog/Ubuntu18.04/111.png" srcset="/img/loading.gif" /><p>参考一个大神的视频:<a href="https://www.bilibili.com/video/av23152537" target="_blank" rel="noopener">https://www.bilibili.com/video/av23152537</a></p><h3 id="在恢复模式下修改文件"><a href="#在恢复模式下修改文件" class="headerlink" title="在恢复模式下修改文件"></a>在恢复模式下修改文件</h3><p>我在一天之内改文件改的Ubuntu不能解锁进入桌面,于是又探索了一下<br>首先进入恢复模式之后是不能修改文件的,要先输入以下命令</p><pre><code>mount -o remount,rw /</code></pre><p>这样就可以修改文件了,把你之前修改的文件改回原来的.按住Ctrl+Alt+delete就能重启了进入系统了.</p><h2 id="设置软件开机启动"><a href="#设置软件开机启动" class="headerlink" title="设置软件开机启动"></a>设置软件开机启动</h2><p>ubuntu18.04不再使用initd管理系统，改用systemd。</p><p>使用systemd设置开机启动,为了像以前一样，在/etc/rc.local中设置开机启动程序，需要以下几步：</p><p><strong>systemd默认读取/etc/systemd/system下的配置文件，该目录下的文件会链接/lib/systemd/system/下的文件。一般系统安装完/lib/systemd/system/下会有rc-local.service文件，即我们需要的配置文件链接过来：</strong></p><pre><code class="shell">ln -fs /lib/systemd/system/rc-local.service /etc/systemd/system/rc-local.servicecd /etc/systemd/system/cat rc-local.service</code></pre><p>rc-local.service内容</p><pre><code class="shell">#  SPDX-License-Identifier: LGPL-2.1+##  This file is part of systemd.##  systemd is free software; you can redistribute it and/or modify it#  under the terms of the GNU Lesser General Public License as published by#  the Free Software Foundation; either version 2.1 of the License, or#  (at your option) any later version.# This unit gets pulled automatically into multi-user.target by# systemd-rc-local-generator if /etc/rc.local is executable.[Unit]Description=/etc/rc.local CompatibilityDocumentation=man:systemd-rc-local-generator(8)ConditionFileIsExecutable=/etc/rc.localAfter=network.target[Service]Type=forkingExecStart=/etc/rc.local startTimeoutSec=0RemainAfterExit=yesGuessMainPID=no1) [Unit] 区块：启动顺序与依赖关系。 </code></pre><ol><li><p>[Unit] 区块：启动顺序与依赖关系。 </p></li><li><p>[Service] 区块：启动行为,如何启动，启动类型。 </p></li></ol><p><strong>创建/etc/rc.local文件</strong></p><pre><code class="shell">touch /etc/rc.local</code></pre><p><strong>赋可执行权限</strong></p><pre><code class="shell">chmod 755 /etc/rc.local</code></pre><p><strong>编辑rc.local，添加需要开机启动的任务</strong></p><pre><code class="shell">#!/bin/bashecho &quot;test rc &quot; &gt; /var/test.log</code></pre><p><strong>执行reboot重启系统，然后查看test.log</strong></p><h2 id="安装wine-企业微信，-qq等"><a href="#安装wine-企业微信，-qq等" class="headerlink" title="安装wine    企业微信， qq等"></a>安装wine    企业微信， qq等</h2><p><a href="https://laravel-china.org/articles/17517" target="_blank" rel="noopener">https://laravel-china.org/articles/17517</a></p><h2 id="设置mac主题"><a href="#设置mac主题" class="headerlink" title="设置mac主题"></a>设置mac主题</h2><p>安装gnome-tweaks  扩展有bylr，net speed等</p><p>主题：<a href="https://www.gnome-look.org/p/1241688/" target="_blank" rel="noopener">https://www.gnome-look.org/p/1241688/</a>       /etc/share/themes</p><p>图标：<a href="https://github.com/vbay/CSDN-CODE/tree/master/Ubuntu18.04-tutorials-themes/icons" target="_blank" rel="noopener">https://github.com/vbay/CSDN-CODE/tree/master/Ubuntu18.04-tutorials-themes/icons</a>  ~/.icons</p><p>锁屏及壁纸：<a href="https://www.opendesktop.org/p/1207015" target="_blank" rel="noopener">https://www.opendesktop.org/p/1207015</a>  脚本存放目录：/.local/share/nautilus/scripts</p><p>dock栏：dash-to-dock</p><h2 id="ubuntu下载器"><a href="#ubuntu下载器" class="headerlink" title="ubuntu下载器"></a>ubuntu下载器</h2><p>安装uget、aria2</p><pre><code class="shell">sudo add-apt-repository ppa:plushuang-tw/uget-stablesudo apt-get updatesudo apt-get install ugetsudo add-apt-repository ppa:t-tujikawa/ppasudo apt-get updatesudo apt-get install aria2</code></pre><p>安装 uget-integrator</p><pre><code class="shell">sudo add-apt-repository ppa:uget-team/ppasudo apt updatesudo apt install uget-integrator</code></pre><p>安装chrome插件：uget-chrome-wrapper</p><pre><code class="shell">sudo add-apt-repository ppa:slgobinath/uget-chrome-wrappersudo apt updatesudo apt install uget-chrome-wrapper</code></pre><h2 id="终端切换su失败显示认证失败"><a href="#终端切换su失败显示认证失败" class="headerlink" title="终端切换su失败显示认证失败"></a>终端切换su失败显示认证失败</h2><pre><code class="shell">sudo passwd Password: &lt;--- 输入安装时那个用户的密码 Enter new UNIX password: &lt;--- 新的Root用户密码 Retype new UNIX password: &lt;--- 重复新的Root用户密码 passwd：已成功更新密码 </code></pre><h2 id="给应用程序添加图标"><a href="#给应用程序添加图标" class="headerlink" title="给应用程序添加图标"></a>给应用程序添加图标</h2><p>比如给Postman添加快捷访问方式</p><pre><code class="shell">sudo ln -s /opt/Postman/Postman /usr/bin/postmancat &gt; ~/.local/share/applications/postman.desktop &lt;&lt;EOL</code></pre><p>输入以下代码</p><pre><code class="shell">[Desktop Entry]Encoding=UTF-8Name=PostmanExec=/opt/Postman/postman           //注意目录 Icon=/opt/Postman/app/resources/app/assets/icon.png  //为图标目录  此为默认安装目录Terminal=falseType=ApplicationCategories=Development;EOL</code></pre><p>然后进入~/.local/share/applications/目录把postman.desktop文件赋予可执行权限</p><h2 id="终端美化"><a href="#终端美化" class="headerlink" title="终端美化"></a>终端美化</h2><p>首先安装 <a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Installing-ZSH" target="_blank" rel="noopener">zsh</a></p><pre><code class="shell">Ubuntusudo apt install zsh</code></pre><p>安装<a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">oh-my-zsh</a></p><pre><code class="shell">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</code></pre><p>查看当前系统的终端有哪些</p><pre><code class="shell">cat /etc/shells</code></pre><p>查看当前终端</p><pre><code class="shell">echo $SHELL</code></pre><p>如果不是zsh 应该切换为zsh</p><pre><code class="shell">postmanchsh -s `which zsh`reboot  //重启电脑生效</code></pre><p>更改主题</p><pre><code class="shell">vim ~/.zshrc</code></pre><p>主题推荐：ys、angoster注：运行 sudo update-grub 可能会导致之前手动删除的引导再次出现彻底删除需要进入/etc/grub.d/寻找想要删除的引导所在的文件注释掉即可</p><p>一些主题：<a href="https://www.zhihu.com/question/33277508" target="_blank" rel="noopener">zsh-themes</a></p><p>查看当前安装的主题cd /usr/share/fonts/truetype/</p><pre><code class="shell">ls ~/.oh-my-zsh/themes</code></pre><p>注：安装完后可能会存在一些快捷命令无法使用，那是因为之前是在<del>/.bashrc里面设置了相关参数（比如PATH）应该讲</del>/.bashrc里面做的修改  同样修改到~/.zshrc 中新建一个终端就完事儿了！</p><p>修改agnoster主题</p><p>主题目录：</p><pre><code class="shell">~/.oh-my-zsh/themes</code></pre><p>去掉前缀</p><pre><code class="shell">prompt_context() {  if [[ &quot;$USER&quot; != &quot;$DEFAULT_USER&quot; || -n &quot;$SSH_CLIENT&quot; ]]; then    prompt_segment black default &quot;%(!.%{%F{yellow}%}.)$USER@%m&quot;   //将此行注释掉 #  fi}</code></pre><h2 id="vscode使用zsh-agnoster"><a href="#vscode使用zsh-agnoster" class="headerlink" title="vscode使用zsh agnoster"></a>vscode使用zsh agnoster</h2><pre><code class="shell">cd /usr/share/fonts/truetype/sudo git clone https://github.com/abertsch/Menlo-for-Powerline.gitsudo fc-cache -f -v   //刷新字体</code></pre><p>Vs Code的用户设置.json中加入代码：</p><pre><code>&quot;terminal.integrated.fontFamily&quot;: &quot;Menlo for Powerline&quot;</code></pre><h2 id="全局搜索工具albert"><a href="#全局搜索工具albert" class="headerlink" title="全局搜索工具albert:"></a>全局搜索工具albert:</h2><pre><code class="shell">sudo add-apt-repository ppa:noobslab/macbuntusudo apt-get updatesudo apt-get install albert</code></pre><p>官网有解决无公钥的方法：</p><p><a href="https://albertlauncher.github.io/docs/installing/" target="_blank" rel="noopener">https://albertlauncher.github.io/docs/installing/</a></p><h2 id="搜狗输入法安装"><a href="#搜狗输入法安装" class="headerlink" title="搜狗输入法安装"></a>搜狗输入法安装</h2><p><a href="https://www.jianshu.com/p/c936a8a2180e" target="_blank" rel="noopener">https://www.jianshu.com/p/c936a8a2180e</a><br>输入法设置<br>fcitx-config-gtk3</p><h2 id="无法获得锁的问题"><a href="#无法获得锁的问题" class="headerlink" title="无法获得锁的问题"></a>无法获得锁的问题</h2><p>E: 无法获得锁 /var/lib/dpkg/lock – open (11: 资源临时不可用)</p><p>E: 无法对管理目录(/var/lib/dpkg/)加锁</p><pre><code class="shell">//其中一条sudo rm /var/lib/apt/lists/locksudo rm /var/lib/dpkg/lock</code></pre><p>E: 无法获得锁 /var/cache/apt/archives/lock – open (11 资源临时不可用)</p><p>E: 无法锁定下载目录</p><pre><code class="shell">sudo rm /var/cache/apt/archives/lock sudo rm /var/lib/dpkg/lock</code></pre><h2 id="没有release文件"><a href="#没有release文件" class="headerlink" title="没有release文件"></a>没有release文件</h2><p><a href="https://www.cnblogs.com/BlogOfMr-Leo/p/8512136.html" target="_blank" rel="noopener">https://www.cnblogs.com/BlogOfMr-Leo/p/8512136.html</a></p><pre><code class="shell">cd etc/apt/sources.list.d/</code></pre><p>对应的.list  .list.save 中的bionic 改为xenial</p><h2 id="安装Google-chrome"><a href="#安装Google-chrome" class="headerlink" title="安装Google chrome"></a>安装Google chrome</h2><pre><code class="shell">wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.debsudo dpkg -i google-chrome-stable_current_amd64.debsudo apt-get -f install</code></pre><h2 id="shadowsocks-安装（elementary-无法使用ss-qt5）"><a href="#shadowsocks-安装（elementary-无法使用ss-qt5）" class="headerlink" title="shadowsocks 安装（elementary 无法使用ss-qt5）"></a>shadowsocks 安装（elementary 无法使用ss-qt5）</h2><p>规则列表<a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt" target="_blank" rel="noopener">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</a></p><pre><code class="shell">sudo pip install shadowsockssslocal -c xxx.json</code></pre><p><strong>!出现问题后：</strong><br>用vim打开文件：(该路径请根据自己的系统情况自行修改，如果不知道该文件在哪里的话，可以使用find命令查找文件位置)</p><pre><code class="shell">vim /usr/local/lib/python2.7/dist-packages/shadowsocks/crypto/openssl.py </code></pre><p>ubuntu18.04的位置在</p><pre><code class="shell">~/.local/lib/python2.7/site-packages/shadowsocks/crypto/openssl.py</code></pre><p><strong>搜索cleanup</strong></p><p>将libcrypto.EVP_CIPHER_CTX_cleanup.argtypes = (c_void_p,)<br>改为libcrypto.EVP_CIPHER_CTX_reset.argtypes = (c_void_p,)</p><p><strong>再次搜索cleanup</strong></p><p>将libcrypto.EVP_CIPHER_CTX_cleanup(self._ctx)<br>改为libcrypto.EVP_CIPHER_CTX_reset(self._ctx)<br>保存并退出<br>启动shadowsocks服务：service shadowsocks start 或 sslocal -c ss配置文件目录</p><h2 id="设置文件夹为英文"><a href="#设置文件夹为英文" class="headerlink" title="设置文件夹为英文"></a>设置文件夹为英文</h2><pre><code class="shell">export LANG=en_USxdg-user-dirs-gtk-update//重启reboot//弹出提示框,点击取消,即可</code></pre><h2 id="查看进程、强制杀死进程"><a href="#查看进程、强制杀死进程" class="headerlink" title="查看进程、强制杀死进程"></a>查看进程、强制杀死进程</h2><pre><code class="shell">ps -auxsudo kill -s 9 xxx(进程号)</code></pre><h2 id="18-04安装网易云"><a href="#18-04安装网易云" class="headerlink" title="18.04安装网易云"></a>18.04安装网易云</h2><p>官网下载安装包  安装</p><p>图标不能打开</p><pre><code class="shell"># 找到 netease-cloud-music.desktop 文件# 默认为  /usr/share/applications/netease-cloud-music.desktopdpkg -L netease-cloud-music|grep desktop                   # 对应行修改为 Exec=sh -c &quot;unset SESSION_MANAGER &amp;&amp; netease-cloud-music %U&quot;sudo vi /usr/share/applications/netease-cloud-music.desktop</code></pre><p>将Exec 那行改成</p><pre><code class="shell">Exec=sh -c &quot;unset SESSION_MANAGER &amp;&amp; netease-cloud-music %U&quot;</code></pre><p>！！！操作前请确保无网易云进程</p><pre><code class="shell">ps -aux|grep netease</code></pre><h2 id="解决-linux下编译-sh文件报错-“-XXXX-unexpected-operator”-问题"><a href="#解决-linux下编译-sh文件报错-“-XXXX-unexpected-operator”-问题" class="headerlink" title="解决 linux下编译.sh文件报错 “[: XXXX: unexpected operator” 问题"></a>解决 linux下编译.sh文件报错 “[: XXXX: unexpected operator” 问题</h2><p>后来发现，因为ubuntu默认的sh是连接到dash的,又因为dash跟bash的不兼容所以出错了.执行时可以把sh换成bash文件名.sh来执行.成功.dash是什么东西,查了一下,应该也是一种shell,貌似用户对它的诟病颇多。</p><p>修改sh默认连接到bash的一种方法:</p><pre><code class="shell">sudo dpkg-reconfigure dash</code></pre><p>选择no 即可!</p><p>或者编译文件时不要不用./运行  使用bash 文件名运行</p><pre><code class="shell">./xxx.sh   //rongbash xxx.sh //right</code></pre><h2 id="cat、tail、head、grep、sed查看文件任意几行的数据"><a href="#cat、tail、head、grep、sed查看文件任意几行的数据" class="headerlink" title="cat、tail、head、grep、sed查看文件任意几行的数据"></a>cat、tail、head、grep、sed查看文件任意几行的数据</h2><pre><code class="shell"># 显示file文件里匹配foo字串那行以及上下5行grep -C 5 foo file # 显示foo及前5行grep -B 5 foo file # 显示foo及后5行grep -A 5 foo file # grep结果太多， 可否只取前面10行匹配的结果grep ...... | head -10# 查看最后1000行的数据cat filename | tail -n 1000# 查看1000到3000行的数据cat filename | head -n 3000 | tail -n +1000# 打印文件所有内容cat filename # 打印文件最后1000行的数据tail filename -n 1000 # 打印文件第1000行开始以后的内容tail filename -n +1000 # 打印前1000的内容head filename -n 1000  </code></pre><h2 id="隐藏dash-to-dock"><a href="#隐藏dash-to-dock" class="headerlink" title="隐藏dash-to-dock"></a>隐藏dash-to-dock</h2><pre><code class="shell">// 如果想要恢复  改为true即可gsettings set org.gnome.shell.extensions.dash-to-dock autohide falsegsettings set org.gnome.shell     .extensions.dash-to-dock dock-fixed falsegsettings set org.gnome.shell.extensions.dash-to-dock intellihide false    </code></pre><h3 id="修复Ubuntu-grub引导"><a href="#修复Ubuntu-grub引导" class="headerlink" title="修复Ubuntu grub引导"></a>修复Ubuntu grub引导</h3><p>在win10的基础上安装了ubuntu16.04，但是后来重新安装了win10，导致ubuntu的引导消失。最终用<strong>U盘启动盘</strong>进行修复，解决了这个问题</p><ol><li><p>制作一个U盘启动盘。下载对应的ubuntu系统，用UltraISO制作Ubuntu U盘启动。</p></li><li><p>打开电脑后选择u盘启动盘，然后选择try ubuntu without install。试用不安装。</p></li><li><p>进入ubuntu系统后，连接好网络，打开终端，输入下面命令，按照提示操作。</p></li></ol><pre><code class="shell"># 可能会出现无法apt-get update 的现象  # 需要去Ubuntu软件更新 更改一下源 默认是main-sever 需要注：运行 sudo update-grub 可能会导致之前手动删除的引导再次出现彻底删除需要进入/etc/grub.d/寻找想要删除的引导所在的文件注释掉即可更改成国内的源 比如aliyunsudo add-apt-repository ppa:yannubuntu/boot-repair &amp;&amp; sudo apt-get update</code></pre><ol start="4"><li>完成后，终端中输入下面命令：</li></ol><pre><code class="shell">sudo apt-get install -y boot-repair &amp;&amp; boot-repair  </code></pre><ol start="5"><li>选择 <strong>recommended</strong> <strong>repair</strong>就行了 根据提示多等几分钟就ok了</li></ol><p>参考：<a href="https://blog.csdn.net/laocaibcc229/article/details/79274412" target="_blank" rel="noopener">https://blog.csdn.net/laocaibcc229/article/details/79274412</a></p><h2 id="删除grub多余的引导"><a href="#删除grub多余的引导" class="headerlink" title="删除grub多余的引导"></a>删除grub多余的引导</h2><pre><code class="shell">cd /boot/grubsudo vim grub.cfg#里面每一个menuentry 就是一个引导  删除即可</code></pre><p><strong>注：运行 sudo update-grub 可能会导致之前手动删除的引导再次出现彻底删除需要进入/etc/grub.d/寻找想要删除的引导所在的文件注释掉即可</strong></p><h2 id="设置grub主题"><a href="#设置grub主题" class="headerlink" title="设置grub主题"></a>设置grub主题</h2><p>参考：<a href="https://tianyijian.github.io/2018/04/05/ubuntu-grub-beautify/" target="_blank" rel="noopener">https://tianyijian.github.io/2018/04/05/ubuntu-grub-beautify/</a></p><p>几个不错的主题（下载完成后解压进入主题目录运行install.sh文件就好）</p><p><strong>Vimix</strong>：<a href="https://www.gnome-look.org/p/1009236/" target="_blank" rel="noopener">https://www.gnome-look.org/p/1009236/</a></p><p><strong>Griffin</strong>：<a href="https://www.gnome-look.org/p/1237117/" target="_blank" rel="noopener">https://www.gnome-look.org/p/1237117/</a></p><p><strong>Primitivistical</strong>：<a href="https://www.gnome-look.org/p/1280604/" target="_blank" rel="noopener">https://www.gnome-look.org/p/1280604/</a>    </p><pre><code class="shell">cd /etc/grub.dsudo vim 00_header# 添加下面这条命令(记得更换主题名字)GRUB_THEME=/boot/grub/themes/themeName/theme.txtsudo update-grub</code></pre><p>更改grub背景颜色：</p><pre><code class="shell">sudo vim  /usr/share/plymouth/themes/default.grub#黑色：0,0,0,0sudo update-grub</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 语言异常处理</title>
    <link href="/2017/09/04/Go%20%E8%AF%AD%E8%A8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/2017/09/04/Go%20%E8%AF%AD%E8%A8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>“ Go语言追求简洁优雅，所以，Go语言不支持传统的 try…catch…finally 这种异常，因为Go语言的设计者们认为，将异常与控制结构混在一起会很容易使得代码变得混乱。因为开发者很容易滥用异常，甚至一个小小的错误都抛出一个异常。在Go语言中，使用多值返回来返回错误。不要用异常代替错误，更不要用来控制流程。在极个别的情况下，也就是说，遇到真正的异常的情况下（比如除数为0了）。才使用Go中引入的Exception处理：defer, panic, recover。”</p><p>这几个异常的使用场景可以这么简单描述：Go中可以抛出一个panic的异常，然后在defer中通过recover捕获这个异常，然后正常处理。<br>例：</p><pre><code>package mainimport &quot;fmt&quot;func main(){    defer func(){        // 必须要先声明defer，否则不能捕获到panic异常        fmt.Println(&quot;c&quot;)        if err:=recover();err!=nil{            fmt.Println(err)     // 这里的err其实就是panic传入的内容，55        }        fmt.Println(&quot;d&quot;)    }()    f()}func f(){    fmt.Println(&quot;a&quot;)    panic(55)    fmt.Println(&quot;b&quot;)    fmt.Println(&quot;f&quot;)}</code></pre><p>结果：</p><pre><code>    a    c    55    d    exit code 0, process exited normally.</code></pre><p>参考： <a href="http://blog.csdn.net/ghost911_slb/article/details/7831574" target="_blank" rel="noopener">http://blog.csdn.net/ghost911_slb/article/details/7831574</a></p><h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>defer的思想类似于C++中的析构函数，不过Go语言中“析构”的不是对象，而是函数，defer就是用来添加函数结束时执行的语句。注意这里强调的是添加，而不是指定，因为不同于C++中的析构函数是静态的，Go中的defer是动态的。</p><pre><code>func f() (result int) {    defer func() {        result++    }()    return 0}</code></pre><p>上面函数返回1，因为defer中添加了一个函数，在函数返回前改变了命名返回值的值。是不是很好用呢。但是，要注意的是，如果我们的defer语句没有执行，那么defer的函数就不会添加，如果把上面的程序改成这样：</p><pre><code>func f() (result int) {      return 0      defer func() {            result++      }()      return 0}</code></pre><p>上面的函数就返回0了，因为还没来得及添加defer的东西，函数就返回了。</p><p>另外值得一提的是，defer可以多次，这样形成一个defer栈，后defer的语句在函数返回时将先被调用。</p><h2 id="painc"><a href="#painc" class="headerlink" title="painc"></a>painc</h2><p>panic 是用来表示非常严重的不可恢复的错误的。在Go语言中这是一个内置函数，接收一个interface{}类型的值（也就是任何值了）作为参数。panic的作用就像我们平常接触的异常。不过Go可没有try…catch，所以，panic一般会导致程序挂掉（除非recover）。所以，Go语言中的异常，那真的是异常了。你可以试试，调用panic看看，程序立马挂掉，然后Go运行时会打印出调用栈。<br>但是，关键的一点是，即使函数执行的时候panic了，函数不往下走了，运行时并不是立刻向上传递panic，而是到defer那，等defer的东西都跑完了，panic再向上传递。所以这时候 defer 有点类似 try-catch-finally 中的 finally。<br>panic就是这么简单。抛出个真正意义上的异常。</p><h2 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h2><p>上面说到，panic的函数并不会立刻返回，而是先defer，再返回。这时候（defer的时候），如果有办法将panic捕获到，并阻止panic传递，那就异常的处理机制就完善了。</p><p>Go语言提供了recover内置函数，前面提到，一旦panic，逻辑就会走到defer那，那我们就在defer那等着，调用recover函数将会捕获到当前的panic（如果有的话），被捕获到的panic就不会向上传递了，于是，世界恢复了和平。你可以干你想干的事情了。</p><p>不过要注意的是，recover之后，逻辑并不会恢复到panic那个点去，函数还是会在defer之后返回。</p><h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2><p>$a \geq b$<br>$$<br>a \geq b<br>$$</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Painc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用hexo搭建自己的博客</title>
    <link href="/2017/08/27/hexo%20+github%20%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <url>/2017/08/27/hexo%20+github%20%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<div align=center> <img src="https://github.com/zhangzizhao404/markdown-pictures/blob/master/MyBlog/Hexo.png?raw=true" srcset="/img/loading.gif" style="zoom:50%" /></div>## 准备工作- 下载node.js并安装（官网下载安装），默认会安装npm。- 下载安装git（官网下载安装） - 下载安装hexo。方法：打开cmd 运行npm install -g hexo（要翻墙）<h2 id="本地搭建hexo博客"><a href="#本地搭建hexo博客" class="headerlink" title="本地搭建hexo博客"></a>本地搭建hexo博客</h2><ul><li>新建一个文件夹，如MyBlog</li><li>进入该文件夹内，右击运行git，输入：hexo init（生成hexo模板，可能要翻墙）</li><li>生成完模板，运行npm install（目前貌似不用运行这一步）</li><li>最后运行：hexo server （运行程序，访问本地localhost:4000可以看到博客已经搭建成功）</li></ul><h2 id="将博客与自己Github关联"><a href="#将博客与自己Github关联" class="headerlink" title="将博客与自己Github关联"></a>将博客与自己Github关联</h2><ul><li>在Github上创建名字为XXX.github.io的项目，XXX为自己的github用户名。</li><li>打开本地的MyBlog文件夹项目内的_config.yml配置文件，将其中的type设置为git<pre><code>    deploy    type: git    repository: git@github.com:zhangzizhao404/zhangzizhao404.github.io.git    branch: master</code></pre>（Linux系统repository 使用ssh）</li><li>运行：npm install hexo-deployer-git –save</li><li>运行：hexo g（本地生成静态文件）</li><li>运行：hexo d（将本地静态文件推送至Github）</li><li>进入Github 中XXX.github.io项目 setting 中找到gitpage访问<a href="https://zhangzizhao404.github.io/" target="_blank" rel="noopener">https://zhangzizhao404.github.io/</a></li></ul><h2 id="添加新文章"><a href="#添加新文章" class="headerlink" title="添加新文章"></a>添加新文章</h2><p>打开Hexo目录下的source文件夹，所有的文章都会以md形式保存在_post文件夹中，只要在_post文件夹中新建md类型的文档，就能在执行hexo g的时候被渲染。 新建的文章头需要添加一些yml信息，如下所示：</p><hr><pre><code>title: hello-world   //在此处添加你的标题。date: 2014-11-7 08:55:29   //在此处输入你编辑这篇文章的时间。categories: Exercise   //在此处输入这篇文章的分类。toc: true  //在此处设定是否开启目录，需要主题支持。</code></pre><hr><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>如果成功完成了上述的全部步骤，恭喜你，你已经搭建了一个最为简单且基础的博客。但是这个博客还非常简单， 没有个人的定制，操作也比较复杂，下面的进阶技巧将会让你获得对Hexo更为深入的了解。</p><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><p>博客已经搭建好，也能通过github的域名访问，但总归还是用自己的域名比较舒服。因为我们需要设置将自己的域名绑定到github这个博客项目上。</p><ul><li><p>域名提供商设置<br>  添加2条A记录：<br>  @—&gt;192.30.252.154<br>  @—&gt;192.30.252.153</p><p>  添加一条CNAME记录：<br>  CNAME—&gt;tengzhangchao.github.io</p></li><li><p>博客添加CNAME文件<br>配置完域名解析后，进入博客目录，在source目录下新建CNAME文件，写入域名，如：kongqi404.top</p></li><li><p>运行：hexo g</p></li><li><p>运行：hexo d</p></li></ul><h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2><p>$a \geq b$<br>$$<br>a \geq b<br>$$</p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
